// Copyright 2023 PingCAP, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"bufio"
	"flag"
	"fmt"
	"log"
	"log/slog"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"sort"
	"strconv"
)

const (
	fileHeader = `// Copyright 2024 PingCAP, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated by generate_perror/main.go
// Generated with:
//     %s
package main

var MysqlErrNameToNum = map[string]int{
`
)

var (
	tidbCodePath string
)

func init() {
	flag.StringVar(&tidbCodePath, "path", "../../tidb", "Path to TiDB source code root directory.")
}

func checkNewErr(errCode string, i int, nameToNum map[string]int) {
	if v, ok := nameToNum[errCode]; ok {
		if i != v {
			if errCode != "handler" {
				// Ignore the HA_ERR codes, which are all 'handler'
				log.Printf("Duplicate error errCode %s (%d != %d)", errCode, i, v)
			}
		}
	} else {
		nameToNum[errCode] = i
	}
}

func scanErrCodeFile(fileName string, nameToNum map[string]int) {
	f, err := os.Open(fileName)
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()
	s := bufio.NewScanner(f)
	r := regexp.MustCompile(`^\s+(\w+)*\s+=\s+(\d+)$`)
	for s.Scan() {
		m := r.FindStringSubmatch(s.Text())
		if len(m) == 3 && m[1] != "" && m[2] != "" {
			i, err := strconv.Atoi(m[2])
			if err != nil {
				log.Fatal(err)
			}
			checkNewErr(m[1], i, nameToNum)
		}
	}
	if s.Err() != nil {
		log.Fatal(s.Err())
	}
}

type ErrorCodeAndName struct {
	Code int
	Name string
}

func main() {
	NameToNum := make(map[string]int)

	// First extract the known error names => numbers from TiDB errno module

	// Second extract the known error names => numbers from TiDB parser/mysql module

	// Last use the perror program to extract error names from 1..20000 from MySQL

	flag.Parse()

	scanErrCodeFile(filepath.Join(tidbCodePath, "/pkg/errno/errcode.go"), NameToNum)
	errnoCodes := len(NameToNum)
	log.Printf("Got %d error codes from errno/errcode.go!", errnoCodes)
	scanErrCodeFile(tidbCodePath+"/pkg/parser/mysql/errcode.go", NameToNum)
	parserCodes := len(NameToNum) - errnoCodes
	log.Printf("Got %d New error codes from parser/mysql/errcode.go!", parserCodes)

	perrorVersion, err := exec.Command("perror", "-V").Output()
	if err != nil {
		log.Fatalf("Failed to get version info from perror: %s", err)
	}

	// similar to:
	//seq 1 100000 | xargs perror 2> /dev/null | grep '^MySQL error code MY-[0-9]* ([A-Z_]*).*' | sed 's/^MySQL error code MY-0*\([[:digit:]]*\) (\([^)]*\)).*/"\2": \1,/'
	maxError := 20000
	log.Printf("Running perror for error codes 1..%d, may take some time...", maxError)
	for i := 1; i <= maxError; i++ {
		if i%1000 == 0 {
			fmt.Printf("\r%d", i)
		}
		cmd := exec.Command("perror", strconv.Itoa(i))
		stdout, err := cmd.StdoutPipe()
		if err != nil {
			log.Fatalf("Error setting up call to perrror: %s", err)
		}
		if err = cmd.Start(); err != nil {
			log.Fatalf("Error starting call to perror: %s", err)
		}
		s := bufio.NewScanner(stdout)
		r := regexp.MustCompile(`^MySQL error code MY-0*(\d+) \((\w+)\)`)
		for s.Scan() {
			m := r.FindStringSubmatch(s.Text())
			if len(m) == 3 && m[1] != "" && m[2] != "" {
				c, err := strconv.Atoi(m[1])
				if err != nil {
					log.Fatal(err)
				}
				if c != i {
					log.Fatalf("perror gave error with wrong number? (Want: %d Got: %d)", i, c)
				}
				checkNewErr(m[2], i, NameToNum)
			}
		}
		err = cmd.Wait()
		if err != nil {
			slog.Debug("Warning: Call to perror failed", "errorcode", i, "error", err)
		}
	}
	if maxError >= 1000 {
		fmt.Printf("\r")
	}
	log.Printf("Got %d New error codes from perror!", len(NameToNum)-parserCodes-errnoCodes)
	f, err := os.Create("perror.go")
	if err != nil {
		log.Fatalf("Failed to create perror.go: %s", err)
	}
	defer f.Close()
	w := bufio.NewWriter(f)
	_, err = w.WriteString(fmt.Sprintf(fileHeader, perrorVersion))

	if err != nil {
		log.Fatalf("Failed to write fileHeader to file: %s", err)
	}

	codes := make([]ErrorCodeAndName, 0, len(NameToNum))
	for k, v := range NameToNum {
		codes = append(codes, ErrorCodeAndName{Code: v, Name: k})
	}
	sort.Slice(codes, func(i, j int) bool {
		return codes[i].Code < codes[j].Code || codes[i].Code == codes[j].Code && codes[i].Name < codes[j].Name
	})
	for i := range codes {
		_, err = w.WriteString("\t\"" + codes[i].Name + `": ` + strconv.Itoa(codes[i].Code) + ",\n")
		if err != nil {
			log.Fatalf("Failed to write error code to file: %s", err)
		}
	}
	_, err = w.WriteString("}\n")
	if err != nil {
		log.Fatalf("Failed to write closing line to file: %s", err)
	}
	w.Flush()
}
